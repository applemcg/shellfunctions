
# Whats next? {#whatsNext}

Before taking  a peek at what's  next, it's time to assess  where you are.
First, you've used these commands and shell built-ins,
in more or less the order encountered in the text:


    
    echo
    date
    declare
    for
    do
    done
    set
    eval
    local
    shift
    history
    grep
    awk
    source
    tee
    chmod
    cat
    printf

    

If you have any questions about them, it's quite simple to search for
**bash shell** *command-name* in your favorite search engine.

You now possess the skills to begin crafting your own function library
and make it available for later terminal sessions.  You are now able
to collect and re-use functions as you come to need them.  You'll
collect them, store and re-use them as multiple instances of the one
case you have worked in the book.

As you do that, you'll recognize other challenges:

* how do I use these functions as part of another library?

* can I repair a function quickly as the need arises and easily restore it 
  to its proper library?

* it seems I'm getting a large collection of functions: how do I keep them
  straight?

## Looking ahead {#whats-next-looking}

The very next subject I'm planning is that of library management.  I've 
functions on hand to:

* capture a daily log of when functions were created.

* quickly update a function library with additions or changes

* delete a function or move a function from one library to another, 

This all belongs to a practice I've established on the content and form
of a function library:

* building a Quick-Reference, which may be part of 

* more extensive documentation

* what you may, may not, and must do when *source*ing a library.

This is all supported by what I've called: *Then only backup
system you'll ever need*. That said, in the last two years, I've been
an avid user of [github](http://github.com/applemcg).  Since I'm
not yet that experienced with **git**, so what you'll see in the
backup system I offer might be called a crutch, but I use it as the
routine check-point, preserving files in a more accessible state than
git offers: i.e., using ordinary commands, such as **cp** to
retrieve a backed-up version, which may be more than one edition old.

And to control versions,  the subject of the *cloud*
appears.  At this moment, that includes git, and 
[Dropbox](http://Dropbox.com),  so  a practice  and a  function
library to make that usage as  concise as you need.  In the last month
(Sept-Oct  2013)  I've started  using  Dropbox  as my  virtual  **HOME**
directory.

At some point I will discuss the distinction between using shell
function libraries and the more common parlance of the *shell script*.
If you haven't noticed this yet, I hadn't use the term before.  That's
conscious, since much of my practice is devoted to the command line.
We will need to make the connection between this view of the shell,
and connecting to the business needs.  A good place to do that is
constructing an application suitable for a
[cron_job](http://en.wikipedia.org/wiki/Cron)

## Further ahead 

I have shell functions for the major application areas of:

* file backup -- "The Only Backup You'll Ever Need"

* database -- I've been carrying around a personal copy of the 
  too-little-used 
  [RDB](http://www.amazon.com/Relational-Database-Management-Prentice-Hall-Software/dp/013938622X ).   
  Originally built on [awk](http://www.grymoire.com/Unix/Awk.html)
  there are now *perl*-based implementations.   I've stayed close
  to the author's original idea that *the shell is the only 4GL 
  you'll ever need*.

* documentation -- quite honestly, I'd worked on a nice auxiliary
  library for Markdown, the technology used in this book.  However,
  I'm doing most of my personal writing in Emacs' OrgMode.  Which
  brings up another question: what is the better way to leave text for
  the ages?

Mail me if [you have questions](mailto:mcgowan@alum.mit.edu?subject=whatsNext)


